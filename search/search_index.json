{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome","title":"Welcome \ud83d\udc4b","text":"<p><code>mf2py</code> is a full-featured microformats2 (mf2) parser implemented in Python.</p> <p>mf2py implements the full mf2 specification, including backward compatibility with microformats1.</p>"},{"location":"#installation","title":"Installation \ud83d\udcbb","text":"<p>To install <code>mf2py</code>, run the following command:</p> <pre><code>pip install mf2py\n</code></pre>"},{"location":"#quickstart","title":"Quickstart \ud83d\ude80","text":"<p>Import the parser using:</p> <pre><code>import mf2py\n</code></pre>"},{"location":"#parse-a-file","title":"Parse a File","text":"<p>Parse a file containing HTML:</p> <pre><code>with open('file/content.html','r') as file:\n    obj = mf2py.parse(doc=file)\n</code></pre>"},{"location":"#parse-a-string","title":"Parse a String","text":"<p>Parse string containing HTML content:</p> <pre><code>content = '&lt;article class=\"h-entry\"&gt;&lt;h1 class=\"p-name\"&gt;Hello&lt;/h1&gt;&lt;/article&gt;'\nobj = mf2py.parse(doc=content)\n</code></pre>"},{"location":"#parse-a-html-document-retrieved-from-a-url","title":"Parse a HTML Document Retrieved from a URL","text":"<p>Parse content from a URL:</p> <pre><code>obj = mf2py.parse(url=\"http://tommorris.org/\")\n</code></pre> <p><code>parse</code> is a convenience method that actually delegates to <code>mf2py.Parser</code> to do the real work. More sophisticated behaviors are available by invoking the object directly.</p>"},{"location":"#format-options","title":"Format Options","text":"<p>Retrieve parsed microformats as a Python dictionary or JSON string:</p> <pre><code>p = mf2py.Parser(...)\np.to_dict()  # returns a python dictionary\np.to_json()  # returns a JSON string\n</code></pre>"},{"location":"#filter-by-microformat-type","title":"Filter by Microformat Type","text":"<p>Filter by microformat type:</p> <pre><code>p.to_dict(filter_by_type=\"h-entry\")\np.to_json(filter_by_type=\"h-entry\")\n</code></pre>"},{"location":"#experimental-features","title":"Experimental Features \ud83e\uddea","text":"<ul> <li>Pass the optional argument <code>img_with_alt=True</code> to either the <code>Parser</code> object or to the <code>parse</code> method to enable parsing of the <code>alt</code> attribute of <code>&lt;img&gt;</code> tags according to issue: image alt text is lost during parsing. By default this is <code>False</code> to be backwards compatible.</li> </ul>"},{"location":"#faqs","title":"FAQs \u2753","text":"<ul> <li>I passed <code>mf2py.parse()</code> a BeautifulSoup document, and it got modified!</li> </ul> <p>Yes, mf2py currently does that. We're working on preventing it! Hopefully soon.</p>"},{"location":"#testing-environments","title":"Testing Environments \ud83c\udf10","text":"<p>A hosted live version of mf2py can be found at python.microformats.io.</p>"},{"location":"#contributing","title":"Contributing \ud83d\udee0\ufe0f","text":"<p>We welcome contributions and bug reports via Github, and on the microformats wiki.</p> <p>We to follow the IndieWebCamp code of conduct. Please be respectful of other contributors, and forge a spirit of positive co-operation without discrimination or disrespect.</p>"},{"location":"#license","title":"License \ud83e\uddd1\u200d\u2696\ufe0f","text":"<p><code>mf2py</code> is licensed under an MIT License.</p>"},{"location":"changelog/","title":"Change Log","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#112-2018-08-08","title":"1.1.2 - 2018-08-08","text":"<ul> <li>add parsing for iframe.u-*[src] (#116)</li> <li>bug fix: reduced implied urls (#117)</li> <li>bug fix: don't collapse whitespace between tags</li> <li>specify explicit versions for dependencies</li> <li>revert BeautifulSoup copying added in 1.1.1 due to bugs (eg #108)</li> <li>misc performance improvements</li> </ul>"},{"location":"changelog/#111-2018-06-15","title":"1.1.1 - 2018-06-15","text":"<ul> <li>streamline backcompat to use JSON only.</li> <li>fix multiple mf1 root rel-tag parsing </li> <li>correct url and photo for hreview.</li> <li>add rules for nested hreview. update backcompat to use multiple matches in old properties.</li> <li>fix <code>rel-tag</code> to <code>p-category</code> conversion so that other classes are not lost.</li> <li>use original authored html for <code>e-*</code> parsing in backcompat</li> <li>make classes and rels into unordered (alphabetically ordered) deduped arrays.</li> <li>only use class names for mf2 which follow the naming rules</li> <li>fix <code>parse</code> method to use default html parser.</li> <li>always use the first value for attributes for rels.</li> <li>correct AM/PM conversion in datetime value class pattern.</li> <li>add ordinal date parsing to datetimes value class pattern. ordinal date is normalised to YYYY-MM-DD</li> <li>remove hack for html tag classes since that is fixed in new BS</li> <li>better whitespace algorithm for <code>name</code> and <code>html.value</code> parsing</li> <li>experimental flag for including <code>alt</code> in <code>u-photo</code> parsing</li> <li>make a copy of the BeautifulSoup given by user to work on for parsing to prevent changes to original doc</li> <li>bump version to 1.1.1 </li> </ul>"},{"location":"changelog/#110-2018-03-16","title":"1.1.0 - 2018-03-16","text":"<ul> <li>bump version to 1.1.0 since it is a \"major\" change </li> <li>added tests for new implied name rules</li> <li>modified earlier tests to accommodate new rules</li> <li>use space separator instead of \"T\"</li> <li>Don't add \"00\" seconds unless authored</li> <li>use TZ authored in separate <code>value</code> element</li> <li>only use first found <code>value</code> of a particular type <code>date</code>, <code>time</code>, or <code>timezone</code>.</li> <li>move backcompat rules into JSON files</li> <li>reorganise value class pattern parsing into new files</li> <li>add datetime_helpers to organise datetime parsing rules</li> <li>reorganise tests</li> <li>remove Heroku frontend, point to mf2py-web and python.microformats.io instead in README.</li> <li>remove Flask and gunicorn requirements</li> <li>add debug info with description, version, url and the html parser used </li> </ul>"},{"location":"changelog/#106-2018-03-04","title":"1.0.6 - 2018-03-04","text":"<ul> <li>strip leading/trailing white space for <code>e-*[html]</code>. update the corresponding tests</li> <li>blank values explicitly authored are allowed as property values </li> <li>include <code>alt</code> or <code>src</code> from <code>&lt;img&gt;</code> in parsing for <code>p-*</code> and <code>e-*[value]</code></li> <li>parse <code>title</code> from <code>&lt;link&gt;</code> for <code>p-*</code> resolves #84 </li> <li>and <code>poster</code> from <code>&lt;video&gt;</code> for <code>u-*</code> resolves #76 </li> <li>use <code>html5lib</code> as default parser</li> <li>use the final redirect URL resolves #62 </li> <li>update requirements to use BS4 v4.6.0 and html5lib v1.0.1</li> <li>drop support for Python 2.6 as html5lib dropped support</li> </ul>"},{"location":"changelog/#105-2016-05-09","title":"1.0.5 - 2016-05-09","text":"<ul> <li>Implied property checks now ignore alt=\"\", treating it the same as   if no alt value is defined.</li> <li>Support for using a custom dict implementation by setting   mf2py.Parser.dict_class. collections.OrderedDict yields much nicer   output for hosted parsers.</li> </ul>"},{"location":"changelog/#104-2016-03-21","title":"1.0.4 - 2016-03-21","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Performance improvement changing simple calls to soup.find_all to   a manual iteration over .contents.</li> </ul>"},{"location":"changelog/#103-2016-02-05","title":"1.0.3 - 2016-02-05","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Performance improvement by limiting number of calls to soup.find_all   in backcompat module. Should not be any functional changes.</li> </ul>"},{"location":"changelog/#102-2016-01-26","title":"1.0.2 - 2016-01-26","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Backward compatibility parsing for rel=tag properties. These are now converted   to p-category based on the last path segment of the tag URI as spec'd in   http://microformats.org/wiki/h-entry#Parser_Compatibility</li> <li>Optional property html_parser to specify the html parser that BeautifulSoup   should use (e.g., \"lxml\" or \"html5lib\")</li> </ul>"},{"location":"changelog/#101-2015-12-11","title":"1.0.1 - 2015-12-11","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li><code>u-*</code> properties are now parsed from <code>&lt;link&gt;</code> elements per the updated spec   http://microformats.org/wiki/microformats2-parsing-issues#link_elements_and_u-_parsing</li> </ul>"},{"location":"changelog/#100-2015-10-05","title":"1.0.0 - 2015-10-05","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Version number bumped to 1.0.0 following community discussion.</li> </ul>"},{"location":"changelog/#028-2015-09-21","title":"0.2.8 - 2015-09-21","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Stricter checks that Parser.init params are actually None before   ignoring them.</li> </ul>"},{"location":"changelog/#027-2015-08-03","title":"0.2.7 - 2015-08-03","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Now produces unicode strings for every key and value, no more byte   strings anywhere.</li> <li>Do not add 'T' between date and time when normalizing dates</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Unit tests for running the microformats test suite</li> </ul>"},{"location":"changelog/#026-2015-05-06","title":"0.2.6 - 2015-05-06","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>New top-level \"rel-urls\" entry, contains rich data parsed from rel   links, organized by URL.</li> </ul>"},{"location":"changelog/#025-2015-03-01","title":"0.2.5 - 2015-03-01","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>convenience method <code>mf2py.parse</code> that takes the same arguments as Parser   and returns a dict.</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>nested h- classes now parse their \"value\" based on the property   they represent (p-, u-, dt-), so for example \"p-in-reply-to   h-cite\" would have a name as its value and \"u-in-reply-to h-cite\"   will have a URL.</li> </ul>"},{"location":"changelog/#024-2015-02-13","title":"0.2.4 - 2015-02-13","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Add rel=bookmark to backward compat parsing rules based (translated   to u-url in mf2)</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Parser constructor now takes explicit named arguments instead of   **kwargs, for saner behavior when called with unnamed arguments.</li> <li>Bugfix: Empty href=\"\" attributes are now properly interpreted as   the current document's URL.</li> </ul>"},{"location":"changelog/#023-2015-02-07","title":"0.2.3 - 2015-02-07","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Minor Py3 compatibility fix</li> <li>Correct typo <code>test_requires</code> -&gt; <code>tests_require</code> in setup.py</li> </ul>"},{"location":"changelog/#022-2015-02-05","title":"0.2.2 - 2015-02-05","text":""},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Started keeping a changelog!</li> <li>Use a better method for extracting HTML for an e-* property</li> <li>Correct BeautifulSoup4 dependency in setup.py to fix error with   installation from PyPI.</li> <li>Buffed up docstrings for public methods.</li> </ul>"},{"location":"parser/","title":"Parse a Document","text":""},{"location":"parser/#parser","title":"Parser","text":"<p>         Bases: <code>object</code></p> <p>Object to parse a document for microformats and return them in appropriate formats.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>file or string or BeautifulSoup doc</code> <p>file handle, text of content to parse, or BeautifulSoup document. If None, it will be fetched from given url</p> <code>None</code> <code>url</code> <code>string</code> <p>url of the file to be processed. Optionally extracted from base-element of given doc</p> <code>None</code> <code>html_parser</code> <code>string</code> <p>optional, select a specific HTML parser. Valid options from the BeautifulSoup documentation are: \"html\", \"xml\", \"html5\", \"lxml\", \"html5lib\", and \"html.parser\" defaults to \"html5lib\"</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>useragent</code> <code>string</code> <p>the User-Agent string for the Parser</p> Source code in <code>mf2py/parser.py</code> <pre><code>class Parser(object):\n\"\"\"Object to parse a document for microformats and return them in\n    appropriate formats.\n\n    Args:\n      doc (file or string or BeautifulSoup doc): file handle, text of content\n        to parse, or BeautifulSoup document. If None, it will be fetched from\n        given url\n      url (string): url of the file to be processed. Optionally extracted from\n        base-element of given doc\n      html_parser (string): optional, select a specific HTML parser. Valid\n        options from the BeautifulSoup documentation are:\n        \"html\", \"xml\", \"html5\", \"lxml\", \"html5lib\", and \"html.parser\"\n        defaults to \"html5lib\"\n\n    Attributes:\n      useragent (string): the User-Agent string for the Parser\n    \"\"\"\n\n    ua_desc = 'mf2py - microformats2 parser for python'\n    ua_url = \"https://github.com/microformats/mf2py\"\n    useragent = '{0} - version {1} - {2}'.format(ua_desc, __version__, ua_url)\n\n    dict_class = dict\n\n    def __init__(self, doc=None, url=None, html_parser=None, img_with_alt=False):\n        self.__url__ = None\n        self.__doc__ = None\n        self._preserve_doc = False\n        self.__parsed__ = self.dict_class([\n            ('items', []),\n            ('rels', self.dict_class()),\n            ('rel-urls', self.dict_class()),\n            ('debug', self.dict_class([\n                ('description', self.ua_desc),\n                ('source', self.ua_url),\n                ('version', text_type(__version__))\n            ]))\n        ])\n        self.__img_with_alt__ = img_with_alt\n\n        # use default parser if none specified\n        self.__html_parser__ = html_parser or 'html5lib'\n\n        if url is not None:\n            self.__url__ = url\n\n            if doc is None:\n                data = requests.get(self.__url__, headers={\n                    'User-Agent': self.useragent,\n                })\n\n                # update to final URL after redirects\n                self.__url__ = data.url\n\n                # HACK: check for character encodings and use 'correct' data\n                if 'charset' in data.headers.get('content-type', ''):\n                    doc = data.text\n                else:\n                    doc = data.content\n\n        if doc is not None:\n\n            if isinstance(doc, BeautifulSoup) or isinstance(doc, Tag):\n                self.__doc__ = doc\n                self._preserve_doc = True\n            else:\n                try:\n                    # try the user-given html parser or default html5lib\n                    self.__doc__ = BeautifulSoup(doc, features=self.__html_parser__)\n                except FeatureNotFound:\n                    # maybe raise a warning?\n                    # else switch to default use\n                    self.__doc__ = BeautifulSoup(doc)\n\n        # update actual parser used\n        # uses builder.NAME from BeautifulSoup\n        if isinstance(self.__doc__, BeautifulSoup) and self.__doc__.builder is not None:\n            self.__html_parser__ = self.__doc__.builder.NAME\n        else:\n            self.__html_parser__ = None\n\n        # check for &lt;base&gt; tag\n        if self.__doc__:\n\n            poss_base = next((el for el in get_descendents(self.__doc__)\n                              if el.name == 'base'), None)\n            if poss_base:\n                poss_base_url = poss_base.get('href')  # try to get href\n                if poss_base_url:\n                    if urlparse(poss_base_url).netloc:\n                        # base specifies an absolute path\n                        self.__url__ = poss_base_url\n                    elif self.__url__:\n                        # base specifies a relative path\n                        self.__url__ = try_urljoin(self.__url__, poss_base_url)\n\n        if self.__doc__ is not None:\n            # parse!\n            self.parse()\n\n    def parse(self):\n\"\"\"Does the work of actually parsing the document. Done automatically\n        on initialization.\n        \"\"\"\n        self._default_date = None\n        # _default_date exists to provide implementation for rules described\n        # in legacy value-class-pattern. basically, if you have two dt-\n        # properties and one does not have the full date, it can use the\n        # existing date as a template.\n        # see value-class-pattern#microformats2_parsers on wiki.\n        # see also the implied_relative_datetimes testcase.\n\n        def handle_microformat(root_class_names, el, value_property=None,\n                               simple_value=None, backcompat_mode=False):\n\"\"\"Handles a (possibly nested) microformat, i.e. h-*\n            \"\"\"\n            properties = self.dict_class()\n            children = []\n            self._default_date = None\n            # for processing implied properties: collects if property types (p, e, u, d(t)) or children (h) have been processed\n            parsed_types_aggregation = set()\n\n            if backcompat_mode:\n                el = backcompat.apply_rules(el, self.__html_parser__)\n                root_class_names = mf2_classes.root(el.get('class', []))\n\n            # parse for properties and children\n            for child in get_children(el):\n                child_props, child_children, child_parsed_types_aggregation = parse_props(child)\n                for key, new_value in child_props.items():\n                    prop_value = properties.get(key, [])\n                    prop_value.extend(new_value)\n                    properties[key] = prop_value\n                children.extend(child_children)\n                parsed_types_aggregation.update(child_parsed_types_aggregation)\n\n            # complex h-* objects can take their \"value\" from the\n            # first explicit property (\"name\" for p-* or \"url\" for u-*)\n            if value_property and value_property in properties:\n                simple_value = properties[value_property][0]\n\n            # if some properties not already found find in implied ways unless in backcompat mode\n            if not backcompat_mode:\n                # stop implied name if any p-*, e-*, h-* is already found\n                if \"name\" not in properties and parsed_types_aggregation.isdisjoint(\"peh\"):\n                    properties[\"name\"] = [implied_properties.name(el, base_url=self.__url__)]\n\n                if \"photo\" not in properties and parsed_types_aggregation.isdisjoint(\"uh\"):\n                    x = implied_properties.photo(el, self.dict_class, self.__img_with_alt__, base_url=self.__url__)\n                    if x is not None:\n                        properties[\"photo\"] = [x]\n\n                # stop implied url if any u-* or h-* is already found\n                if \"url\" not in properties and parsed_types_aggregation.isdisjoint(\"uh\"):\n                    x = implied_properties.url(el, base_url=self.__url__)\n                    if x is not None:\n                        properties[\"url\"] = [x]\n\n            # build microformat with type and properties\n            microformat = self.dict_class([\n                (\"type\", [text_type(class_name)\n                          for class_name in sorted(root_class_names)]),\n                (\"properties\", properties),\n            ])\n            if str(el.name) == \"area\":\n                shape = get_attr(el, 'shape')\n                if shape is not None:\n                    microformat['shape'] = text_type(shape)\n\n                coords = get_attr(el, 'coords')\n                if coords is not None:\n                    microformat['coords'] = text_type(coords)\n\n            # insert children if any\n            if children:\n                microformat[\"children\"] = children\n\n            Id = get_attr(el, 'id')\n            if Id:\n                microformat['id'] = Id\n\n            # simple value is the parsed property value if it were not\n            # an h-* class\n            if simple_value is not None:\n                if isinstance(simple_value, dict):\n                    # for e-* properties, the simple value will be\n                    # {\"html\":..., \"value\":...}  which we should fold\n                    # into the microformat object\n                    # details: https://github.com/microformats/mf2py/issues/35\n                    microformat.update(simple_value)\n                else:\n                    microformat[\"value\"] = text_type(simple_value)\n\n            return microformat\n\n        def parse_props(el):\n\"\"\"Parse the properties from a single element\n            \"\"\"\n            props = self.dict_class()\n            children = []\n            # for processing implied properties: collects if property types (p, e, u, d(t)) or children (h) have been processed\n            parsed_types_aggregation = set()\n\n            classes = el.get(\"class\", [])\n            filtered_classes = mf2_classes.filter_classes(classes)\n            # Is this element a microformat2 root?\n            root_class_names = filtered_classes['h']\n            backcompat_mode = False\n\n            # Is this element a microformat1 root?\n            if not root_class_names:\n                root_class_names = backcompat.root(classes)\n                backcompat_mode = True\n\n            if root_class_names:\n                parsed_types_aggregation.add('h')\n\n            # Is this a property element (p-*, u-*, etc.) flag\n            # False is default\n            is_property_el = False\n\n            # Parse plaintext p-* properties.\n            p_value = None\n            for prop_name in filtered_classes['p']:\n                is_property_el = True\n                parsed_types_aggregation.add('p')\n                prop_value = props.setdefault(prop_name, [])\n\n                # if value has not been parsed then parse it\n                if p_value is None:\n                    p_value = text_type(parse_property.text(el, base_url=self.__url__))\n\n                if root_class_names:\n                    prop_value.append(handle_microformat(\n                        root_class_names, el, value_property=\"name\",\n                        simple_value=p_value, backcompat_mode=backcompat_mode))\n                else:\n                    prop_value.append(p_value)\n\n            # Parse URL u-* properties.\n            u_value = None\n            for prop_name in filtered_classes['u']:\n                is_property_el = True\n                parsed_types_aggregation.add('u')\n                prop_value = props.setdefault(prop_name, [])\n\n                # if value has not been parsed then parse it\n                if u_value is None:\n                    u_value = parse_property.url(el, self.dict_class, self.__img_with_alt__, base_url=self.__url__)\n\n                if root_class_names:\n                    prop_value.append(handle_microformat(\n                        root_class_names, el, value_property=\"url\",\n                        simple_value=u_value, backcompat_mode=backcompat_mode))\n                else:\n                    if isinstance(u_value, self.dict_class):\n                        prop_value.append(u_value)\n                    else:\n                        prop_value.append(text_type(u_value))\n\n            # Parse datetime dt-* properties.\n            dt_value = None\n            for prop_name in filtered_classes['dt']:\n                is_property_el = True\n                parsed_types_aggregation.add('d')\n                prop_value = props.setdefault(prop_name, [])\n\n                # if value has not been parsed then parse it\n                if dt_value is None:\n                    dt_value, new_date = parse_property.datetime(\n                        el, self._default_date)\n                    # update the default date\n                    if new_date:\n                        self._default_date = new_date\n\n                if root_class_names:\n                    stops_implied_name = True\n                    prop_value.append(handle_microformat(\n                        root_class_names, el,\n                        simple_value=text_type(dt_value), backcompat_mode=backcompat_mode))\n                else:\n                    if dt_value is not None:\n                        prop_value.append(text_type(dt_value))\n\n            # Parse embedded markup e-* properties.\n            e_value = None\n            for prop_name in filtered_classes['e']:\n                is_property_el = True\n                parsed_types_aggregation.add('e')\n                prop_value = props.setdefault(prop_name, [])\n\n                # if value has not been parsed then parse it\n                if e_value is None:\n                    # send original element for parsing backcompat\n                    if el.original is None:\n                        embedded_el = el\n                    else:\n                        embedded_el = el.original\n                    if self._preserve_doc:\n                        embedded_el = copy.copy(embedded_el)\n                    temp_fixes.rm_templates(embedded_el)\n                    e_value = parse_property.embedded(embedded_el, base_url=self.__url__)\n\n                if root_class_names:\n                    stops_implied_name = True\n                    prop_value.append(handle_microformat(\n                        root_class_names, el, simple_value=e_value, backcompat_mode=backcompat_mode))\n                else:\n                    prop_value.append(e_value)\n\n            # if this is not a property element, but it is a h-* microformat,\n            # add it to our list of children\n            if not is_property_el and root_class_names:\n                children.append(handle_microformat(root_class_names, el, backcompat_mode=backcompat_mode))\n            # parse child tags, provided this isn't a microformat root-class\n            if not root_class_names:\n                for child in get_children(el):\n                    child_properties, child_microformats, child_parsed_types_aggregation = parse_props(child)\n                    for prop_name in child_properties:\n                        v = props.get(prop_name, [])\n                        v.extend(child_properties[prop_name])\n                        props[prop_name] = v\n                    children.extend(child_microformats)\n                    parsed_types_aggregation.update(child_parsed_types_aggregation)\n            return props, children, parsed_types_aggregation\n\n        def parse_rels(el):\n\"\"\"Parse an element for rel microformats\n            \"\"\"\n            rel_attrs = [text_type(rel) for rel in get_attr(el, 'rel')]\n            # if rel attributes exist\n            if rel_attrs is not None:\n                # find the url and normalise it\n                url = try_urljoin(self.__url__, el.get('href', ''))\n                value_dict = self.__parsed__[\"rel-urls\"].get(url,\n                                                             self.dict_class())\n\n                # 1st one wins\n                if \"text\" not in value_dict:\n                    value_dict[\"text\"] = el.get_text().strip()\n\n                url_rels = value_dict.get(\"rels\", [])\n                value_dict[\"rels\"] = url_rels\n\n                for knownattr in (\"media\", \"hreflang\", \"type\", \"title\"):\n                    x = get_attr(el, knownattr)\n                    # 1st one wins\n                    if x is not None and knownattr not in value_dict:\n                        value_dict[knownattr] = text_type(x)\n\n                self.__parsed__[\"rel-urls\"][url] = value_dict\n\n                for rel_value in rel_attrs:\n                    value_list = self.__parsed__[\"rels\"].get(rel_value, [])\n                    if url not in value_list:\n                        value_list.append(url)\n                    if rel_value not in url_rels:\n                        url_rels.append(rel_value)\n\n                    self.__parsed__[\"rels\"][rel_value] = value_list\n                if \"alternate\" in rel_attrs:\n                    alternate_list = self.__parsed__.get(\"alternates\", [])\n                    alternate_dict = self.dict_class()\n                    alternate_dict[\"url\"] = url\n                    x = \" \".join(\n                        [r for r in rel_attrs if not r == \"alternate\"])\n                    if x != \"\":\n                        alternate_dict[\"rel\"] = x\n                    alternate_dict[\"text\"] = text_type(el.get_text().strip())\n                    for knownattr in (\"media\", \"hreflang\", \"type\", \"title\"):\n                        x = get_attr(el, knownattr)\n                        if x is not None:\n                            alternate_dict[knownattr] = text_type(x)\n                    alternate_list.append(alternate_dict)\n                    self.__parsed__[\"alternates\"] = alternate_list\n\n        def parse_el(el, ctx):\n\"\"\"Parse an element for microformats\n            \"\"\"\n            classes = el.get(\"class\", [])\n\n            # find potential microformats in root classnames h-*\n            potential_microformats = mf2_classes.root(classes)\n\n            # if potential microformats found parse them\n            if potential_microformats:\n                result = handle_microformat(potential_microformats, el)\n                ctx.append(result)\n            else:\n                # find backcompat root classnames\n                potential_microformats = backcompat.root(classes)\n                if potential_microformats:\n                    result = handle_microformat(potential_microformats, el, backcompat_mode=True)\n                    ctx.append(result)\n                else:\n                    # parse child tags\n                    for child in get_children(el):\n                        parse_el(child, ctx)\n\n        ctx = []\n        # start parsing at root element of the document\n        parse_el(self.__doc__, ctx)\n        self.__parsed__[\"items\"] = ctx\n\n        # parse for rel values\n        for el in get_descendents(self.__doc__):\n            if el.name in ('a', 'area', 'link') and el.has_attr('rel'):\n                parse_rels(el)\n\n        # sort the rels array in rel-urls since this should be unordered set\n        for url in self.__parsed__[\"rel-urls\"]:\n            if 'rels' in self.__parsed__[\"rel-urls\"][url]:\n                rels = self.__parsed__[\"rel-urls\"][url]['rels']\n                self.__parsed__[\"rel-urls\"][url]['rels'] =  unordered_list(rels)\n\n        # add actual parser used to debug\n        # uses builder.NAME from BeautifulSoup\n        if self.__html_parser__:\n            self.__parsed__[\"debug\"][\"markup parser\"] = text_type(self.__html_parser__)\n        else:\n            self.__parsed__[\"debug\"][\"markup parser\"] = text_type('unknown')\n\n    def to_dict(self, filter_by_type=None):\n\"\"\"Get a dictionary version of the parsed microformat document.\n\n        Args:\n          filter_by_type (string, optional): only include top-level items of\n            the given h-* type. Defaults to None.\n\n        Returns:\n            dict: representation of the parsed microformats document\n        \"\"\"\n        if filter_by_type is None:\n            return self.__parsed__\n        else:\n            return [x for x in self.__parsed__['items']\n                    if filter_by_type in x['type']]\n\n    def to_json(self, pretty_print=False, filter_by_type=None):\n\"\"\"Get a json-encoding string version of the parsed microformats document\n\n        Args:\n          pretty_print (bool, optional): Encode the json document with\n            linebreaks and indents to improve readability. Defaults to False.\n          filter_by_type (bool, optional): only include top-level items of\n            the given h-* type\n\n        Returns:\n            string: a json-encoded string\n        \"\"\"\n\n        if pretty_print:\n            return json.dumps(self.to_dict(filter_by_type), indent=4,\n                              separators=(', ', ': '))\n        else:\n            return json.dumps(self.to_dict(filter_by_type))\n</code></pre>"},{"location":"parser/#mf2py.parser.Parser.parse","title":"<code>parse()</code>","text":"<p>Does the work of actually parsing the document. Done automatically on initialization.</p> Source code in <code>mf2py/parser.py</code> <pre><code>def parse(self):\n\"\"\"Does the work of actually parsing the document. Done automatically\n    on initialization.\n    \"\"\"\n    self._default_date = None\n    # _default_date exists to provide implementation for rules described\n    # in legacy value-class-pattern. basically, if you have two dt-\n    # properties and one does not have the full date, it can use the\n    # existing date as a template.\n    # see value-class-pattern#microformats2_parsers on wiki.\n    # see also the implied_relative_datetimes testcase.\n\n    def handle_microformat(root_class_names, el, value_property=None,\n                           simple_value=None, backcompat_mode=False):\n\"\"\"Handles a (possibly nested) microformat, i.e. h-*\n        \"\"\"\n        properties = self.dict_class()\n        children = []\n        self._default_date = None\n        # for processing implied properties: collects if property types (p, e, u, d(t)) or children (h) have been processed\n        parsed_types_aggregation = set()\n\n        if backcompat_mode:\n            el = backcompat.apply_rules(el, self.__html_parser__)\n            root_class_names = mf2_classes.root(el.get('class', []))\n\n        # parse for properties and children\n        for child in get_children(el):\n            child_props, child_children, child_parsed_types_aggregation = parse_props(child)\n            for key, new_value in child_props.items():\n                prop_value = properties.get(key, [])\n                prop_value.extend(new_value)\n                properties[key] = prop_value\n            children.extend(child_children)\n            parsed_types_aggregation.update(child_parsed_types_aggregation)\n\n        # complex h-* objects can take their \"value\" from the\n        # first explicit property (\"name\" for p-* or \"url\" for u-*)\n        if value_property and value_property in properties:\n            simple_value = properties[value_property][0]\n\n        # if some properties not already found find in implied ways unless in backcompat mode\n        if not backcompat_mode:\n            # stop implied name if any p-*, e-*, h-* is already found\n            if \"name\" not in properties and parsed_types_aggregation.isdisjoint(\"peh\"):\n                properties[\"name\"] = [implied_properties.name(el, base_url=self.__url__)]\n\n            if \"photo\" not in properties and parsed_types_aggregation.isdisjoint(\"uh\"):\n                x = implied_properties.photo(el, self.dict_class, self.__img_with_alt__, base_url=self.__url__)\n                if x is not None:\n                    properties[\"photo\"] = [x]\n\n            # stop implied url if any u-* or h-* is already found\n            if \"url\" not in properties and parsed_types_aggregation.isdisjoint(\"uh\"):\n                x = implied_properties.url(el, base_url=self.__url__)\n                if x is not None:\n                    properties[\"url\"] = [x]\n\n        # build microformat with type and properties\n        microformat = self.dict_class([\n            (\"type\", [text_type(class_name)\n                      for class_name in sorted(root_class_names)]),\n            (\"properties\", properties),\n        ])\n        if str(el.name) == \"area\":\n            shape = get_attr(el, 'shape')\n            if shape is not None:\n                microformat['shape'] = text_type(shape)\n\n            coords = get_attr(el, 'coords')\n            if coords is not None:\n                microformat['coords'] = text_type(coords)\n\n        # insert children if any\n        if children:\n            microformat[\"children\"] = children\n\n        Id = get_attr(el, 'id')\n        if Id:\n            microformat['id'] = Id\n\n        # simple value is the parsed property value if it were not\n        # an h-* class\n        if simple_value is not None:\n            if isinstance(simple_value, dict):\n                # for e-* properties, the simple value will be\n                # {\"html\":..., \"value\":...}  which we should fold\n                # into the microformat object\n                # details: https://github.com/microformats/mf2py/issues/35\n                microformat.update(simple_value)\n            else:\n                microformat[\"value\"] = text_type(simple_value)\n\n        return microformat\n\n    def parse_props(el):\n\"\"\"Parse the properties from a single element\n        \"\"\"\n        props = self.dict_class()\n        children = []\n        # for processing implied properties: collects if property types (p, e, u, d(t)) or children (h) have been processed\n        parsed_types_aggregation = set()\n\n        classes = el.get(\"class\", [])\n        filtered_classes = mf2_classes.filter_classes(classes)\n        # Is this element a microformat2 root?\n        root_class_names = filtered_classes['h']\n        backcompat_mode = False\n\n        # Is this element a microformat1 root?\n        if not root_class_names:\n            root_class_names = backcompat.root(classes)\n            backcompat_mode = True\n\n        if root_class_names:\n            parsed_types_aggregation.add('h')\n\n        # Is this a property element (p-*, u-*, etc.) flag\n        # False is default\n        is_property_el = False\n\n        # Parse plaintext p-* properties.\n        p_value = None\n        for prop_name in filtered_classes['p']:\n            is_property_el = True\n            parsed_types_aggregation.add('p')\n            prop_value = props.setdefault(prop_name, [])\n\n            # if value has not been parsed then parse it\n            if p_value is None:\n                p_value = text_type(parse_property.text(el, base_url=self.__url__))\n\n            if root_class_names:\n                prop_value.append(handle_microformat(\n                    root_class_names, el, value_property=\"name\",\n                    simple_value=p_value, backcompat_mode=backcompat_mode))\n            else:\n                prop_value.append(p_value)\n\n        # Parse URL u-* properties.\n        u_value = None\n        for prop_name in filtered_classes['u']:\n            is_property_el = True\n            parsed_types_aggregation.add('u')\n            prop_value = props.setdefault(prop_name, [])\n\n            # if value has not been parsed then parse it\n            if u_value is None:\n                u_value = parse_property.url(el, self.dict_class, self.__img_with_alt__, base_url=self.__url__)\n\n            if root_class_names:\n                prop_value.append(handle_microformat(\n                    root_class_names, el, value_property=\"url\",\n                    simple_value=u_value, backcompat_mode=backcompat_mode))\n            else:\n                if isinstance(u_value, self.dict_class):\n                    prop_value.append(u_value)\n                else:\n                    prop_value.append(text_type(u_value))\n\n        # Parse datetime dt-* properties.\n        dt_value = None\n        for prop_name in filtered_classes['dt']:\n            is_property_el = True\n            parsed_types_aggregation.add('d')\n            prop_value = props.setdefault(prop_name, [])\n\n            # if value has not been parsed then parse it\n            if dt_value is None:\n                dt_value, new_date = parse_property.datetime(\n                    el, self._default_date)\n                # update the default date\n                if new_date:\n                    self._default_date = new_date\n\n            if root_class_names:\n                stops_implied_name = True\n                prop_value.append(handle_microformat(\n                    root_class_names, el,\n                    simple_value=text_type(dt_value), backcompat_mode=backcompat_mode))\n            else:\n                if dt_value is not None:\n                    prop_value.append(text_type(dt_value))\n\n        # Parse embedded markup e-* properties.\n        e_value = None\n        for prop_name in filtered_classes['e']:\n            is_property_el = True\n            parsed_types_aggregation.add('e')\n            prop_value = props.setdefault(prop_name, [])\n\n            # if value has not been parsed then parse it\n            if e_value is None:\n                # send original element for parsing backcompat\n                if el.original is None:\n                    embedded_el = el\n                else:\n                    embedded_el = el.original\n                if self._preserve_doc:\n                    embedded_el = copy.copy(embedded_el)\n                temp_fixes.rm_templates(embedded_el)\n                e_value = parse_property.embedded(embedded_el, base_url=self.__url__)\n\n            if root_class_names:\n                stops_implied_name = True\n                prop_value.append(handle_microformat(\n                    root_class_names, el, simple_value=e_value, backcompat_mode=backcompat_mode))\n            else:\n                prop_value.append(e_value)\n\n        # if this is not a property element, but it is a h-* microformat,\n        # add it to our list of children\n        if not is_property_el and root_class_names:\n            children.append(handle_microformat(root_class_names, el, backcompat_mode=backcompat_mode))\n        # parse child tags, provided this isn't a microformat root-class\n        if not root_class_names:\n            for child in get_children(el):\n                child_properties, child_microformats, child_parsed_types_aggregation = parse_props(child)\n                for prop_name in child_properties:\n                    v = props.get(prop_name, [])\n                    v.extend(child_properties[prop_name])\n                    props[prop_name] = v\n                children.extend(child_microformats)\n                parsed_types_aggregation.update(child_parsed_types_aggregation)\n        return props, children, parsed_types_aggregation\n\n    def parse_rels(el):\n\"\"\"Parse an element for rel microformats\n        \"\"\"\n        rel_attrs = [text_type(rel) for rel in get_attr(el, 'rel')]\n        # if rel attributes exist\n        if rel_attrs is not None:\n            # find the url and normalise it\n            url = try_urljoin(self.__url__, el.get('href', ''))\n            value_dict = self.__parsed__[\"rel-urls\"].get(url,\n                                                         self.dict_class())\n\n            # 1st one wins\n            if \"text\" not in value_dict:\n                value_dict[\"text\"] = el.get_text().strip()\n\n            url_rels = value_dict.get(\"rels\", [])\n            value_dict[\"rels\"] = url_rels\n\n            for knownattr in (\"media\", \"hreflang\", \"type\", \"title\"):\n                x = get_attr(el, knownattr)\n                # 1st one wins\n                if x is not None and knownattr not in value_dict:\n                    value_dict[knownattr] = text_type(x)\n\n            self.__parsed__[\"rel-urls\"][url] = value_dict\n\n            for rel_value in rel_attrs:\n                value_list = self.__parsed__[\"rels\"].get(rel_value, [])\n                if url not in value_list:\n                    value_list.append(url)\n                if rel_value not in url_rels:\n                    url_rels.append(rel_value)\n\n                self.__parsed__[\"rels\"][rel_value] = value_list\n            if \"alternate\" in rel_attrs:\n                alternate_list = self.__parsed__.get(\"alternates\", [])\n                alternate_dict = self.dict_class()\n                alternate_dict[\"url\"] = url\n                x = \" \".join(\n                    [r for r in rel_attrs if not r == \"alternate\"])\n                if x != \"\":\n                    alternate_dict[\"rel\"] = x\n                alternate_dict[\"text\"] = text_type(el.get_text().strip())\n                for knownattr in (\"media\", \"hreflang\", \"type\", \"title\"):\n                    x = get_attr(el, knownattr)\n                    if x is not None:\n                        alternate_dict[knownattr] = text_type(x)\n                alternate_list.append(alternate_dict)\n                self.__parsed__[\"alternates\"] = alternate_list\n\n    def parse_el(el, ctx):\n\"\"\"Parse an element for microformats\n        \"\"\"\n        classes = el.get(\"class\", [])\n\n        # find potential microformats in root classnames h-*\n        potential_microformats = mf2_classes.root(classes)\n\n        # if potential microformats found parse them\n        if potential_microformats:\n            result = handle_microformat(potential_microformats, el)\n            ctx.append(result)\n        else:\n            # find backcompat root classnames\n            potential_microformats = backcompat.root(classes)\n            if potential_microformats:\n                result = handle_microformat(potential_microformats, el, backcompat_mode=True)\n                ctx.append(result)\n            else:\n                # parse child tags\n                for child in get_children(el):\n                    parse_el(child, ctx)\n\n    ctx = []\n    # start parsing at root element of the document\n    parse_el(self.__doc__, ctx)\n    self.__parsed__[\"items\"] = ctx\n\n    # parse for rel values\n    for el in get_descendents(self.__doc__):\n        if el.name in ('a', 'area', 'link') and el.has_attr('rel'):\n            parse_rels(el)\n\n    # sort the rels array in rel-urls since this should be unordered set\n    for url in self.__parsed__[\"rel-urls\"]:\n        if 'rels' in self.__parsed__[\"rel-urls\"][url]:\n            rels = self.__parsed__[\"rel-urls\"][url]['rels']\n            self.__parsed__[\"rel-urls\"][url]['rels'] =  unordered_list(rels)\n\n    # add actual parser used to debug\n    # uses builder.NAME from BeautifulSoup\n    if self.__html_parser__:\n        self.__parsed__[\"debug\"][\"markup parser\"] = text_type(self.__html_parser__)\n    else:\n        self.__parsed__[\"debug\"][\"markup parser\"] = text_type('unknown')\n</code></pre>"},{"location":"parser/#mf2py.parser.Parser.to_dict","title":"<code>to_dict(filter_by_type=None)</code>","text":"<p>Get a dictionary version of the parsed microformat document.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by_type</code> <code>string</code> <p>only include top-level items of the given h-* type. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>representation of the parsed microformats document</p> Source code in <code>mf2py/parser.py</code> <pre><code>def to_dict(self, filter_by_type=None):\n\"\"\"Get a dictionary version of the parsed microformat document.\n\n    Args:\n      filter_by_type (string, optional): only include top-level items of\n        the given h-* type. Defaults to None.\n\n    Returns:\n        dict: representation of the parsed microformats document\n    \"\"\"\n    if filter_by_type is None:\n        return self.__parsed__\n    else:\n        return [x for x in self.__parsed__['items']\n                if filter_by_type in x['type']]\n</code></pre>"},{"location":"parser/#mf2py.parser.Parser.to_json","title":"<code>to_json(pretty_print=False, filter_by_type=None)</code>","text":"<p>Get a json-encoding string version of the parsed microformats document</p> <p>Parameters:</p> Name Type Description Default <code>pretty_print</code> <code>bool</code> <p>Encode the json document with linebreaks and indents to improve readability. Defaults to False.</p> <code>False</code> <code>filter_by_type</code> <code>bool</code> <p>only include top-level items of the given h-* type</p> <code>None</code> <p>Returns:</p> Name Type Description <code>string</code> <p>a json-encoded string</p> Source code in <code>mf2py/parser.py</code> <pre><code>def to_json(self, pretty_print=False, filter_by_type=None):\n\"\"\"Get a json-encoding string version of the parsed microformats document\n\n    Args:\n      pretty_print (bool, optional): Encode the json document with\n        linebreaks and indents to improve readability. Defaults to False.\n      filter_by_type (bool, optional): only include top-level items of\n        the given h-* type\n\n    Returns:\n        string: a json-encoded string\n    \"\"\"\n\n    if pretty_print:\n        return json.dumps(self.to_dict(filter_by_type), indent=4,\n                          separators=(', ', ': '))\n    else:\n        return json.dumps(self.to_dict(filter_by_type))\n</code></pre>"}]}